// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `into`

// Rust type: RustOpaqueNom<EstablishedSas>
abstract class EstablishedSas implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<PkDecryption>
abstract class PkDecryption implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<PkEncryption>
abstract class PkEncryption implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PkSigning>>
abstract class PkSigning implements RustOpaqueInterface {
  static PkSigning fromSecretKey({required String key}) =>
      RustLib.instance.api.crateBindingsPkSigningFromSecretKey(key: key);

  factory PkSigning() => RustLib.instance.api.crateBindingsPkSigningNew();

  VodozemacEd25519PublicKey publicKey();

  String secretKey();

  VodozemacEd25519Signature sign({required String message});
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VodozemacSas>>
abstract class VodozemacSas implements RustOpaqueInterface {
  VodozemacEstablishedSas establishSasSecret({required String otherPublicKey});

  factory VodozemacSas() => RustLib.instance.api.crateBindingsVodozemacSasNew();

  String publicKey();
}

// Rust type: RustOpaqueNom<std :: sync :: RwLock < Account >>
abstract class RwLockAccount implements RustOpaqueInterface {}

class DecryptResult {
  final String field0;
  final int field1;

  const DecryptResult({
    required this.field0,
    required this.field1,
  });

  @override
  int get hashCode => field0.hashCode ^ field1.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DecryptResult && runtimeType == other.runtimeType && field0 == other.field0 && field1 == other.field1;
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}

class VodozemacAccount {
  final RwLockAccount account;

  const VodozemacAccount.raw({
    required this.account,
  });

  VodozemacOlmSessionCreationResult createInboundSession(
          {required VodozemacCurve25519PublicKey theirIdentityKey, required String preKeyMessageBase64}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountCreateInboundSession(
          that: this, theirIdentityKey: theirIdentityKey, preKeyMessageBase64: preKeyMessageBase64);

  VodozemacSession createOutboundSession(
          {required VodozemacOlmSessionConfig config,
          required VodozemacCurve25519PublicKey identityKey,
          required VodozemacCurve25519PublicKey oneTimeKey}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountCreateOutboundSession(
          that: this, config: config, identityKey: identityKey, oneTimeKey: oneTimeKey);

  VodozemacCurve25519PublicKey curve25519Key() => RustLib.instance.api.crateBindingsVodozemacAccountCurve25519Key(
        that: this,
      );

  VodozemacEd25519PublicKey ed25519Key() => RustLib.instance.api.crateBindingsVodozemacAccountEd25519Key(
        that: this,
      );

  List<VodozemacOneTimeKey> fallbackKey() => RustLib.instance.api.crateBindingsVodozemacAccountFallbackKey(
        that: this,
      );

  bool forgetFallbackKey() => RustLib.instance.api.crateBindingsVodozemacAccountForgetFallbackKey(
        that: this,
      );

  static VodozemacAccount fromOlmPickleEncrypted({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static VodozemacAccount fromPickleEncrypted({required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  String? generateFallbackKey() => RustLib.instance.api.crateBindingsVodozemacAccountGenerateFallbackKey(
        that: this,
      );

  void generateOneTimeKeys({required BigInt count}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountGenerateOneTimeKeys(that: this, count: count);

  VodozemacIdentityKeys identityKeys() => RustLib.instance.api.crateBindingsVodozemacAccountIdentityKeys(
        that: this,
      );

  void markKeysAsPublished() => RustLib.instance.api.crateBindingsVodozemacAccountMarkKeysAsPublished(
        that: this,
      );

  BigInt maxNumberOfOneTimeKeys() => RustLib.instance.api.crateBindingsVodozemacAccountMaxNumberOfOneTimeKeys(
        that: this,
      );

  factory VodozemacAccount() => RustLib.instance.api.crateBindingsVodozemacAccountNew();

  List<VodozemacOneTimeKey> oneTimeKeys() => RustLib.instance.api.crateBindingsVodozemacAccountOneTimeKeys(
        that: this,
      );

  String pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountPickleEncrypted(that: this, pickleKey: pickleKey);

  Uint8List removeOneTimeKey({required String publicKey}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountRemoveOneTimeKey(that: this, publicKey: publicKey);

  VodozemacEd25519Signature sign({required String message}) =>
      RustLib.instance.api.crateBindingsVodozemacAccountSign(that: this, message: message);

  @override
  int get hashCode => account.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacAccount && runtimeType == other.runtimeType && account == other.account;
}

class VodozemacCurve25519PublicKey {
  final Curve25519PublicKey key;

  const VodozemacCurve25519PublicKey({
    required this.key,
  });

  U8Array32 asBytes() => RustLib.instance.api.crateBindingsVodozemacCurve25519PublicKeyAsBytes(
        that: this,
      );

  static VodozemacCurve25519PublicKey fromBase64({required String base64Key}) =>
      RustLib.instance.api.crateBindingsVodozemacCurve25519PublicKeyFromBase64(base64Key: base64Key);

  static VodozemacCurve25519PublicKey fromSlice({required U8Array32 bytes}) =>
      RustLib.instance.api.crateBindingsVodozemacCurve25519PublicKeyFromSlice(bytes: bytes);

  String toBase64() => RustLib.instance.api.crateBindingsVodozemacCurve25519PublicKeyToBase64(
        that: this,
      );

  @override
  int get hashCode => key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacCurve25519PublicKey && runtimeType == other.runtimeType && key == other.key;
}

class VodozemacEd25519PublicKey {
  final Ed25519PublicKey key;

  const VodozemacEd25519PublicKey({
    required this.key,
  });

  U8Array32 asBytes() => RustLib.instance.api.crateBindingsVodozemacEd25519PublicKeyAsBytes(
        that: this,
      );

  static VodozemacEd25519PublicKey fromBase64({required String base64Key}) =>
      RustLib.instance.api.crateBindingsVodozemacEd25519PublicKeyFromBase64(base64Key: base64Key);

  static VodozemacEd25519PublicKey fromSlice({required U8Array32 bytes}) =>
      RustLib.instance.api.crateBindingsVodozemacEd25519PublicKeyFromSlice(bytes: bytes);

  String toBase64() => RustLib.instance.api.crateBindingsVodozemacEd25519PublicKeyToBase64(
        that: this,
      );

  /// Throws on mismatched signatures
  void verify({required String message, required VodozemacEd25519Signature signature}) => RustLib.instance.api
      .crateBindingsVodozemacEd25519PublicKeyVerify(that: this, message: message, signature: signature);

  @override
  int get hashCode => key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacEd25519PublicKey && runtimeType == other.runtimeType && key == other.key;
}

class VodozemacEd25519Signature {
  final Ed25519Signature signature;

  const VodozemacEd25519Signature({
    required this.signature,
  });

  static VodozemacEd25519Signature fromBase64({required String signature}) =>
      RustLib.instance.api.crateBindingsVodozemacEd25519SignatureFromBase64(signature: signature);

  static VodozemacEd25519Signature fromSlice({required U8Array64 bytes}) =>
      RustLib.instance.api.crateBindingsVodozemacEd25519SignatureFromSlice(bytes: bytes);

  String toBase64() => RustLib.instance.api.crateBindingsVodozemacEd25519SignatureToBase64(
        that: this,
      );

  U8Array64 toBytes() => RustLib.instance.api.crateBindingsVodozemacEd25519SignatureToBytes(
        that: this,
      );

  @override
  int get hashCode => signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacEd25519Signature && runtimeType == other.runtimeType && signature == other.signature;
}

class VodozemacEstablishedSas {
  final EstablishedSas establishedSas;

  const VodozemacEstablishedSas({
    required this.establishedSas,
  });

  String calculateMac({required String input, required String info}) =>
      RustLib.instance.api.crateBindingsVodozemacEstablishedSasCalculateMac(that: this, input: input, info: info);

  String calculateMacDeprecated({required String input, required String info}) => RustLib.instance.api
      .crateBindingsVodozemacEstablishedSasCalculateMacDeprecated(that: this, input: input, info: info);

  Uint8List generateBytes({required String info, required int length}) =>
      RustLib.instance.api.crateBindingsVodozemacEstablishedSasGenerateBytes(that: this, info: info, length: length);

  void verifyMac({required String input, required String info, required String mac}) => RustLib.instance.api
      .crateBindingsVodozemacEstablishedSasVerifyMac(that: this, input: input, info: info, mac: mac);

  @override
  int get hashCode => establishedSas.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacEstablishedSas && runtimeType == other.runtimeType && establishedSas == other.establishedSas;
}

class VodozemacGroupSession {
  final RwLockGroupSession session;

  const VodozemacGroupSession.raw({
    required this.session,
  });

  String encrypt({required String plaintext}) =>
      RustLib.instance.api.crateBindingsVodozemacGroupSessionEncrypt(that: this, plaintext: plaintext);

  static VodozemacGroupSession fromOlmPickleEncrypted({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api
          .crateBindingsVodozemacGroupSessionFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static VodozemacGroupSession fromPickleEncrypted({required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacGroupSessionFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  int messageIndex() => RustLib.instance.api.crateBindingsVodozemacGroupSessionMessageIndex(
        that: this,
      );

  factory VodozemacGroupSession({required VodozemacMegolmSessionConfig config}) =>
      RustLib.instance.api.crateBindingsVodozemacGroupSessionNew(config: config);

  String pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacGroupSessionPickleEncrypted(that: this, pickleKey: pickleKey);

  VodozemacMegolmSessionConfig sessionConfig() => RustLib.instance.api.crateBindingsVodozemacGroupSessionSessionConfig(
        that: this,
      );

  String sessionId() => RustLib.instance.api.crateBindingsVodozemacGroupSessionSessionId(
        that: this,
      );

  String sessionKey() => RustLib.instance.api.crateBindingsVodozemacGroupSessionSessionKey(
        that: this,
      );

  VodozemacInboundGroupSession toInbound() => RustLib.instance.api.crateBindingsVodozemacGroupSessionToInbound(
        that: this,
      );

  @override
  int get hashCode => session.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacGroupSession && runtimeType == other.runtimeType && session == other.session;
}

class VodozemacIdentityKeys {
  final VodozemacEd25519PublicKey ed25519;
  final VodozemacCurve25519PublicKey curve25519;

  const VodozemacIdentityKeys({
    required this.ed25519,
    required this.curve25519,
  });

  @override
  int get hashCode => ed25519.hashCode ^ curve25519.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacIdentityKeys &&
          runtimeType == other.runtimeType &&
          ed25519 == other.ed25519 &&
          curve25519 == other.curve25519;
}

class VodozemacInboundGroupSession {
  final RwLockInboundGroupSession session;

  const VodozemacInboundGroupSession.raw({
    required this.session,
  });

  DecryptResult decrypt({required String encrypted}) =>
      RustLib.instance.api.crateBindingsVodozemacInboundGroupSessionDecrypt(that: this, encrypted: encrypted);

  String? exportAt({required int index}) =>
      RustLib.instance.api.crateBindingsVodozemacInboundGroupSessionExportAt(that: this, index: index);

  String exportAtFirstKnownIndex() =>
      RustLib.instance.api.crateBindingsVodozemacInboundGroupSessionExportAtFirstKnownIndex(
        that: this,
      );

  int firstKnownIndex() => RustLib.instance.api.crateBindingsVodozemacInboundGroupSessionFirstKnownIndex(
        that: this,
      );

  static VodozemacInboundGroupSession fromOlmPickleEncrypted({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api
          .crateBindingsVodozemacInboundGroupSessionFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static VodozemacInboundGroupSession fromPickleEncrypted({required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api
          .crateBindingsVodozemacInboundGroupSessionFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static VodozemacInboundGroupSession import_(
          {required String exportedSessionKey, required VodozemacMegolmSessionConfig config}) =>
      RustLib.instance.api
          .crateBindingsVodozemacInboundGroupSessionImport(exportedSessionKey: exportedSessionKey, config: config);

  factory VodozemacInboundGroupSession({required String sessionKey, required VodozemacMegolmSessionConfig config}) =>
      RustLib.instance.api.crateBindingsVodozemacInboundGroupSessionNew(sessionKey: sessionKey, config: config);

  String pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacInboundGroupSessionPickleEncrypted(that: this, pickleKey: pickleKey);

  String sessionId() => RustLib.instance.api.crateBindingsVodozemacInboundGroupSessionSessionId(
        that: this,
      );

  @override
  int get hashCode => session.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacInboundGroupSession && runtimeType == other.runtimeType && session == other.session;
}

class VodozemacMegolmSessionConfig {
  final MegolmSessionConfig config;

  const VodozemacMegolmSessionConfig({
    required this.config,
  });

  static VodozemacMegolmSessionConfig def() => RustLib.instance.api.crateBindingsVodozemacMegolmSessionConfigVersion1();

  int version() => RustLib.instance.api.crateBindingsVodozemacMegolmSessionConfigVersion(
        that: this,
      );

  static VodozemacMegolmSessionConfig version1() =>
      RustLib.instance.api.crateBindingsVodozemacMegolmSessionConfigVersion1();

  static VodozemacMegolmSessionConfig version2() =>
      RustLib.instance.api.crateBindingsVodozemacMegolmSessionConfigVersion2();

  @override
  int get hashCode => config.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacMegolmSessionConfig && runtimeType == other.runtimeType && config == other.config;
}

class VodozemacOlmMessage {
  final OlmMessage msg;

  const VodozemacOlmMessage({
    required this.msg,
  });

  static VodozemacOlmMessage fromParts({required BigInt messageType, required String ciphertext}) =>
      RustLib.instance.api.crateBindingsVodozemacOlmMessageFromParts(messageType: messageType, ciphertext: ciphertext);

  String message() => RustLib.instance.api.crateBindingsVodozemacOlmMessageMessage(
        that: this,
      );

  BigInt messageType() => RustLib.instance.api.crateBindingsVodozemacOlmMessageMessageType(
        that: this,
      );

  @override
  int get hashCode => msg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is VodozemacOlmMessage && runtimeType == other.runtimeType && msg == other.msg;
}

class VodozemacOlmSessionConfig {
  final OlmSessionConfig config;

  const VodozemacOlmSessionConfig({
    required this.config,
  });

  static VodozemacOlmSessionConfig def() => RustLib.instance.api.crateBindingsVodozemacOlmSessionConfigDef();

  int version() => RustLib.instance.api.crateBindingsVodozemacOlmSessionConfigVersion(
        that: this,
      );

  static VodozemacOlmSessionConfig version1() => RustLib.instance.api.crateBindingsVodozemacOlmSessionConfigVersion1();

  static VodozemacOlmSessionConfig version2() => RustLib.instance.api.crateBindingsVodozemacOlmSessionConfigVersion2();

  @override
  int get hashCode => config.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacOlmSessionConfig && runtimeType == other.runtimeType && config == other.config;
}

class VodozemacOlmSessionCreationResult {
  final VodozemacSession session;
  final String plaintext;

  const VodozemacOlmSessionCreationResult({
    required this.session,
    required this.plaintext,
  });

  @override
  int get hashCode => session.hashCode ^ plaintext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacOlmSessionCreationResult &&
          runtimeType == other.runtimeType &&
          session == other.session &&
          plaintext == other.plaintext;
}

class VodozemacOneTimeKey {
  final String keyid;
  final VodozemacCurve25519PublicKey key;

  const VodozemacOneTimeKey({
    required this.keyid,
    required this.key,
  });

  @override
  int get hashCode => keyid.hashCode ^ key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacOneTimeKey && runtimeType == other.runtimeType && keyid == other.keyid && key == other.key;
}

class VodozemacPkDecryption {
  final PkDecryption pkDecryption;

  const VodozemacPkDecryption.raw({
    required this.pkDecryption,
  });

  String decrypt({required VodozemacPkMessage message}) =>
      RustLib.instance.api.crateBindingsVodozemacPkDecryptionDecrypt(that: this, message: message);

  static VodozemacPkDecryption fromKey({required U8Array32 secretKey}) =>
      RustLib.instance.api.crateBindingsVodozemacPkDecryptionFromKey(secretKey: secretKey);

  static VodozemacPkDecryption fromLibolmPickle({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacPkDecryptionFromLibolmPickle(pickle: pickle, pickleKey: pickleKey);

  factory VodozemacPkDecryption() => RustLib.instance.api.crateBindingsVodozemacPkDecryptionNew();

  Uint8List privateKey() => RustLib.instance.api.crateBindingsVodozemacPkDecryptionPrivateKey(
        that: this,
      );

  String publicKey() => RustLib.instance.api.crateBindingsVodozemacPkDecryptionPublicKey(
        that: this,
      );

  String toLibolmPickle({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacPkDecryptionToLibolmPickle(that: this, pickleKey: pickleKey);

  @override
  int get hashCode => pkDecryption.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacPkDecryption && runtimeType == other.runtimeType && pkDecryption == other.pkDecryption;
}

class VodozemacPkEncryption {
  final PkEncryption pkEncryption;

  const VodozemacPkEncryption({
    required this.pkEncryption,
  });

  VodozemacPkMessage encrypt({required String message}) =>
      RustLib.instance.api.crateBindingsVodozemacPkEncryptionEncrypt(that: this, message: message);

  static VodozemacPkEncryption fromKey({required VodozemacCurve25519PublicKey publicKey}) =>
      RustLib.instance.api.crateBindingsVodozemacPkEncryptionFromKey(publicKey: publicKey);

  @override
  int get hashCode => pkEncryption.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacPkEncryption && runtimeType == other.runtimeType && pkEncryption == other.pkEncryption;
}

class VodozemacPkMessage {
  final Uint8List ciphertext;
  final Uint8List mac;
  final VodozemacCurve25519PublicKey ephemeralKey;

  const VodozemacPkMessage.raw({
    required this.ciphertext,
    required this.mac,
    required this.ephemeralKey,
  });

  static VodozemacPkMessage fromBase64(
          {required String ciphertext, required String mac, required String ephemeralKey}) =>
      RustLib.instance.api
          .crateBindingsVodozemacPkMessageFromBase64(ciphertext: ciphertext, mac: mac, ephemeralKey: ephemeralKey);

  factory VodozemacPkMessage(
          {required List<int> ciphertext,
          required List<int> mac,
          required VodozemacCurve25519PublicKey ephemeralKey}) =>
      RustLib.instance.api
          .crateBindingsVodozemacPkMessageNew(ciphertext: ciphertext, mac: mac, ephemeralKey: ephemeralKey);

  (String, String, String) toBase64() => RustLib.instance.api.crateBindingsVodozemacPkMessageToBase64(
        that: this,
      );

  @override
  int get hashCode => ciphertext.hashCode ^ mac.hashCode ^ ephemeralKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacPkMessage &&
          runtimeType == other.runtimeType &&
          ciphertext == other.ciphertext &&
          mac == other.mac &&
          ephemeralKey == other.ephemeralKey;
}

class VodozemacSession {
  final RwLockSession session;

  const VodozemacSession({
    required this.session,
  });

  String decrypt({required VodozemacOlmMessage message}) =>
      RustLib.instance.api.crateBindingsVodozemacSessionDecrypt(that: this, message: message);

  VodozemacOlmMessage encrypt({required String plaintext}) =>
      RustLib.instance.api.crateBindingsVodozemacSessionEncrypt(that: this, plaintext: plaintext);

  static VodozemacSession fromOlmPickleEncrypted({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacSessionFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static VodozemacSession fromPickleEncrypted({required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacSessionFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  bool hasReceivedMessage() => RustLib.instance.api.crateBindingsVodozemacSessionHasReceivedMessage(
        that: this,
      );

  String pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateBindingsVodozemacSessionPickleEncrypted(that: this, pickleKey: pickleKey);

  VodozemacOlmSessionConfig sessionConfig() => RustLib.instance.api.crateBindingsVodozemacSessionSessionConfig(
        that: this,
      );

  String sessionId() => RustLib.instance.api.crateBindingsVodozemacSessionSessionId(
        that: this,
      );

  @override
  int get hashCode => session.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacSession && runtimeType == other.runtimeType && session == other.session;
}
