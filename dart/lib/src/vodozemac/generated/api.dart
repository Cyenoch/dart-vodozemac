// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

// Rust type: RustOpaqueNom<std :: sync :: RwLock < Account >>
abstract class RwLockAccount implements RustOpaqueInterface {}

class DecryptResult {
  final String field0;
  final int field1;

  const DecryptResult({
    required this.field0,
    required this.field1,
  });

  @override
  int get hashCode => field0.hashCode ^ field1.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DecryptResult && runtimeType == other.runtimeType && field0 == other.field0 && field1 == other.field1;
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}

class VodozemacAccount {
  final RwLockAccount account;

  const VodozemacAccount.raw({
    required this.account,
  });

  Future<VodozemacOlmSessionCreationResult> createInboundSession(
          {required VodozemacCurve25519PublicKey theirIdentityKey, required String preKeyMessageBase64}) =>
      RustLib.instance.api.crateApiVodozemacAccountCreateInboundSession(
          that: this, theirIdentityKey: theirIdentityKey, preKeyMessageBase64: preKeyMessageBase64);

  Future<VodozemacSession> createOutboundSession(
          {required VodozemacOlmSessionConfig config,
          required VodozemacCurve25519PublicKey identityKey,
          required VodozemacCurve25519PublicKey oneTimeKey}) =>
      RustLib.instance.api.crateApiVodozemacAccountCreateOutboundSession(
          that: this, config: config, identityKey: identityKey, oneTimeKey: oneTimeKey);

  VodozemacCurve25519PublicKey curve25519Key() => RustLib.instance.api.crateApiVodozemacAccountCurve25519Key(
        that: this,
      );

  VodozemacEd25519PublicKey ed25519Key() => RustLib.instance.api.crateApiVodozemacAccountEd25519Key(
        that: this,
      );

  List<VodozemacOneTimeKey> fallbackKey() => RustLib.instance.api.crateApiVodozemacAccountFallbackKey(
        that: this,
      );

  bool forgetFallbackKey() => RustLib.instance.api.crateApiVodozemacAccountForgetFallbackKey(
        that: this,
      );

  static Future<VodozemacAccount> fromOlmPickleEncrypted({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacAccountFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static Future<VodozemacAccount> fromPickleEncrypted({required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacAccountFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  Future<String?> generateFallbackKey() => RustLib.instance.api.crateApiVodozemacAccountGenerateFallbackKey(
        that: this,
      );

  Future<void> generateOneTimeKeys({required BigInt count}) =>
      RustLib.instance.api.crateApiVodozemacAccountGenerateOneTimeKeys(that: this, count: count);

  VodozemacIdentityKeys identityKeys() => RustLib.instance.api.crateApiVodozemacAccountIdentityKeys(
        that: this,
      );

  void markKeysAsPublished() => RustLib.instance.api.crateApiVodozemacAccountMarkKeysAsPublished(
        that: this,
      );

  BigInt maxNumberOfOneTimeKeys() => RustLib.instance.api.crateApiVodozemacAccountMaxNumberOfOneTimeKeys(
        that: this,
      );

  factory VodozemacAccount() => RustLib.instance.api.crateApiVodozemacAccountNew();

  List<VodozemacOneTimeKey> oneTimeKeys() => RustLib.instance.api.crateApiVodozemacAccountOneTimeKeys(
        that: this,
      );

  Future<String> pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacAccountPickleEncrypted(that: this, pickleKey: pickleKey);

  Future<VodozemacEd25519Signature> sign({required String message}) =>
      RustLib.instance.api.crateApiVodozemacAccountSign(that: this, message: message);

  @override
  int get hashCode => account.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacAccount && runtimeType == other.runtimeType && account == other.account;
}

class VodozemacCurve25519PublicKey {
  final Curve25519PublicKey key;

  const VodozemacCurve25519PublicKey({
    required this.key,
  });

  U8Array32 asBytes() => RustLib.instance.api.crateApiVodozemacCurve25519PublicKeyAsBytes(
        that: this,
      );

  static VodozemacCurve25519PublicKey fromBase64({required String base64Key}) =>
      RustLib.instance.api.crateApiVodozemacCurve25519PublicKeyFromBase64(base64Key: base64Key);

  static VodozemacCurve25519PublicKey fromSlice({required U8Array32 bytes}) =>
      RustLib.instance.api.crateApiVodozemacCurve25519PublicKeyFromSlice(bytes: bytes);

  String toBase64() => RustLib.instance.api.crateApiVodozemacCurve25519PublicKeyToBase64(
        that: this,
      );

  @override
  int get hashCode => key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacCurve25519PublicKey && runtimeType == other.runtimeType && key == other.key;
}

class VodozemacEd25519PublicKey {
  final Ed25519PublicKey key;

  const VodozemacEd25519PublicKey({
    required this.key,
  });

  U8Array32 asBytes() => RustLib.instance.api.crateApiVodozemacEd25519PublicKeyAsBytes(
        that: this,
      );

  static VodozemacEd25519PublicKey fromBase64({required String base64Key}) =>
      RustLib.instance.api.crateApiVodozemacEd25519PublicKeyFromBase64(base64Key: base64Key);

  static VodozemacEd25519PublicKey fromSlice({required U8Array32 bytes}) =>
      RustLib.instance.api.crateApiVodozemacEd25519PublicKeyFromSlice(bytes: bytes);

  String toBase64() => RustLib.instance.api.crateApiVodozemacEd25519PublicKeyToBase64(
        that: this,
      );

  /// Throws on mismatched signatures
  Future<void> verify({required String message, required VodozemacEd25519Signature signature}) =>
      RustLib.instance.api.crateApiVodozemacEd25519PublicKeyVerify(that: this, message: message, signature: signature);

  @override
  int get hashCode => key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacEd25519PublicKey && runtimeType == other.runtimeType && key == other.key;
}

class VodozemacEd25519Signature {
  final Ed25519Signature signature;

  const VodozemacEd25519Signature({
    required this.signature,
  });

  static VodozemacEd25519Signature fromBase64({required String signature}) =>
      RustLib.instance.api.crateApiVodozemacEd25519SignatureFromBase64(signature: signature);

  static VodozemacEd25519Signature fromSlice({required U8Array64 bytes}) =>
      RustLib.instance.api.crateApiVodozemacEd25519SignatureFromSlice(bytes: bytes);

  String toBase64() => RustLib.instance.api.crateApiVodozemacEd25519SignatureToBase64(
        that: this,
      );

  U8Array64 toBytes() => RustLib.instance.api.crateApiVodozemacEd25519SignatureToBytes(
        that: this,
      );

  @override
  int get hashCode => signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacEd25519Signature && runtimeType == other.runtimeType && signature == other.signature;
}

class VodozemacGroupSession {
  final RwLockGroupSession session;

  const VodozemacGroupSession.raw({
    required this.session,
  });

  Future<String> encrypt({required String plaintext}) =>
      RustLib.instance.api.crateApiVodozemacGroupSessionEncrypt(that: this, plaintext: plaintext);

  static Future<VodozemacGroupSession> fromOlmPickleEncrypted({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacGroupSessionFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static Future<VodozemacGroupSession> fromPickleEncrypted({required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacGroupSessionFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  int messageIndex() => RustLib.instance.api.crateApiVodozemacGroupSessionMessageIndex(
        that: this,
      );

  factory VodozemacGroupSession({required VodozemacMegolmSessionConfig config}) =>
      RustLib.instance.api.crateApiVodozemacGroupSessionNew(config: config);

  Future<String> pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacGroupSessionPickleEncrypted(that: this, pickleKey: pickleKey);

  Future<VodozemacMegolmSessionConfig> sessionConfig() =>
      RustLib.instance.api.crateApiVodozemacGroupSessionSessionConfig(
        that: this,
      );

  String sessionId() => RustLib.instance.api.crateApiVodozemacGroupSessionSessionId(
        that: this,
      );

  Future<String> sessionKey() => RustLib.instance.api.crateApiVodozemacGroupSessionSessionKey(
        that: this,
      );

  VodozemacInboundGroupSession toInbound() => RustLib.instance.api.crateApiVodozemacGroupSessionToInbound(
        that: this,
      );

  @override
  int get hashCode => session.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacGroupSession && runtimeType == other.runtimeType && session == other.session;
}

class VodozemacIdentityKeys {
  final VodozemacEd25519PublicKey ed25519;
  final VodozemacCurve25519PublicKey curve25519;

  const VodozemacIdentityKeys({
    required this.ed25519,
    required this.curve25519,
  });

  @override
  int get hashCode => ed25519.hashCode ^ curve25519.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacIdentityKeys &&
          runtimeType == other.runtimeType &&
          ed25519 == other.ed25519 &&
          curve25519 == other.curve25519;
}

class VodozemacInboundGroupSession {
  final RwLockInboundGroupSession session;

  const VodozemacInboundGroupSession.raw({
    required this.session,
  });

  Future<DecryptResult> decrypt({required String encrypted}) =>
      RustLib.instance.api.crateApiVodozemacInboundGroupSessionDecrypt(that: this, encrypted: encrypted);

  String? exportAt({required int index}) =>
      RustLib.instance.api.crateApiVodozemacInboundGroupSessionExportAt(that: this, index: index);

  String exportAtFirstKnownIndex() => RustLib.instance.api.crateApiVodozemacInboundGroupSessionExportAtFirstKnownIndex(
        that: this,
      );

  int firstKnownIndex() => RustLib.instance.api.crateApiVodozemacInboundGroupSessionFirstKnownIndex(
        that: this,
      );

  static Future<VodozemacInboundGroupSession> fromOlmPickleEncrypted(
          {required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api
          .crateApiVodozemacInboundGroupSessionFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static Future<VodozemacInboundGroupSession> fromPickleEncrypted(
          {required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api
          .crateApiVodozemacInboundGroupSessionFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static VodozemacInboundGroupSession import_(
          {required String sessionKey, required VodozemacMegolmSessionConfig config}) =>
      RustLib.instance.api.crateApiVodozemacInboundGroupSessionImport(sessionKey: sessionKey, config: config);

  factory VodozemacInboundGroupSession({required String sessionKey, required VodozemacMegolmSessionConfig config}) =>
      RustLib.instance.api.crateApiVodozemacInboundGroupSessionNew(sessionKey: sessionKey, config: config);

  Future<String> pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacInboundGroupSessionPickleEncrypted(that: this, pickleKey: pickleKey);

  String sessionId() => RustLib.instance.api.crateApiVodozemacInboundGroupSessionSessionId(
        that: this,
      );

  @override
  int get hashCode => session.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacInboundGroupSession && runtimeType == other.runtimeType && session == other.session;
}

class VodozemacMegolmSessionConfig {
  final MegolmSessionConfig config;

  const VodozemacMegolmSessionConfig({
    required this.config,
  });

  static VodozemacMegolmSessionConfig def() => RustLib.instance.api.crateApiVodozemacMegolmSessionConfigDef();

  int version() => RustLib.instance.api.crateApiVodozemacMegolmSessionConfigVersion(
        that: this,
      );

  static VodozemacMegolmSessionConfig version1() => RustLib.instance.api.crateApiVodozemacMegolmSessionConfigVersion1();

  static VodozemacMegolmSessionConfig version2() => RustLib.instance.api.crateApiVodozemacMegolmSessionConfigVersion2();

  @override
  int get hashCode => config.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacMegolmSessionConfig && runtimeType == other.runtimeType && config == other.config;
}

class VodozemacOlmMessage {
  final OlmMessage msg;

  const VodozemacOlmMessage({
    required this.msg,
  });

  static VodozemacOlmMessage fromParts({required BigInt messageType, required List<int> ciphertext}) =>
      RustLib.instance.api.crateApiVodozemacOlmMessageFromParts(messageType: messageType, ciphertext: ciphertext);

  String message() => RustLib.instance.api.crateApiVodozemacOlmMessageMessage(
        that: this,
      );

  BigInt messageType() => RustLib.instance.api.crateApiVodozemacOlmMessageMessageType(
        that: this,
      );

  @override
  int get hashCode => msg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is VodozemacOlmMessage && runtimeType == other.runtimeType && msg == other.msg;
}

class VodozemacOlmSessionConfig {
  final OlmSessionConfig config;

  const VodozemacOlmSessionConfig({
    required this.config,
  });

  static VodozemacOlmSessionConfig def() => RustLib.instance.api.crateApiVodozemacOlmSessionConfigDef();

  int version() => RustLib.instance.api.crateApiVodozemacOlmSessionConfigVersion(
        that: this,
      );

  static VodozemacOlmSessionConfig version1() => RustLib.instance.api.crateApiVodozemacOlmSessionConfigVersion1();

  static VodozemacOlmSessionConfig version2() => RustLib.instance.api.crateApiVodozemacOlmSessionConfigVersion2();

  @override
  int get hashCode => config.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacOlmSessionConfig && runtimeType == other.runtimeType && config == other.config;
}

class VodozemacOlmSessionCreationResult {
  final VodozemacSession session;
  final String plaintext;

  const VodozemacOlmSessionCreationResult({
    required this.session,
    required this.plaintext,
  });

  @override
  int get hashCode => session.hashCode ^ plaintext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacOlmSessionCreationResult &&
          runtimeType == other.runtimeType &&
          session == other.session &&
          plaintext == other.plaintext;
}

class VodozemacOneTimeKey {
  final String keyid;
  final VodozemacCurve25519PublicKey key;

  const VodozemacOneTimeKey({
    required this.keyid,
    required this.key,
  });

  @override
  int get hashCode => keyid.hashCode ^ key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacOneTimeKey && runtimeType == other.runtimeType && keyid == other.keyid && key == other.key;
}

class VodozemacSession {
  final RwLockSession session;

  const VodozemacSession({
    required this.session,
  });

  Future<String> decrypt({required VodozemacOlmMessage message}) =>
      RustLib.instance.api.crateApiVodozemacSessionDecrypt(that: this, message: message);

  Future<VodozemacOlmMessage> encrypt({required String plaintext}) =>
      RustLib.instance.api.crateApiVodozemacSessionEncrypt(that: this, plaintext: plaintext);

  static Future<VodozemacSession> fromOlmPickleEncrypted({required String pickle, required List<int> pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacSessionFromOlmPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  static Future<VodozemacSession> fromPickleEncrypted({required String pickle, required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacSessionFromPickleEncrypted(pickle: pickle, pickleKey: pickleKey);

  bool hasReceivedMessage() => RustLib.instance.api.crateApiVodozemacSessionHasReceivedMessage(
        that: this,
      );

  Future<String> pickleEncrypted({required U8Array32 pickleKey}) =>
      RustLib.instance.api.crateApiVodozemacSessionPickleEncrypted(that: this, pickleKey: pickleKey);

  Future<VodozemacOlmSessionConfig> sessionConfig() => RustLib.instance.api.crateApiVodozemacSessionSessionConfig(
        that: this,
      );

  String sessionId() => RustLib.instance.api.crateApiVodozemacSessionSessionId(
        that: this,
      );

  @override
  int get hashCode => session.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VodozemacSession && runtimeType == other.runtimeType && session == other.session;
}
